<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Audio Player</title>
    <style>
        .audio-container {
            position: relative;
            width: 300px;
        }

        #playOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            border: none;
            opacity: 0;
            cursor: pointer;
            z-index: 1;
        }

        #playOverlay:focus {
            outline: none;
        }
    </style>
</head>
<body>
    <h1>Audio Player</h1>
    <div class="audio-container">
        <audio id="audioPlayer" controls>
            Your browser doesnâ€™t support the audio tag.
        </audio>
        <button id="playOverlay">Play</button>
    </div>

    <script>
        const audioStreamUrl1 = '{{ url_for("audio_stream1") }}';
        const audioStreamUrl2 = '{{ url_for("audio_stream2") }}';
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const audioPlayer = document.getElementById('audioPlayer');
        const playOverlay = document.getElementById('playOverlay');
        const gainNode = audioContext.createGain();
        gainNode.connect(audioContext.destination);

        let secondsPackageTime = 30;
        let secondsDelayApi = 20;
        let isPlaying = false;
        let firstReproduction = true;
        let nextAudioBuffer = null;
        let currentApi = 0;

        async function fetchAudio(apiUrl) {
            try {
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error('Network response was not ok');
                const audioBlob = await response.blob();
                const arrayBuffer = await audioBlob.arrayBuffer();
                return await audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error('Error to get audio:', error);
                return null;
            }
        }

        async function prepareNextAudio() {
            if (firstReproduction) {
                const audioBuffer1 = await fetchAudio(audioStreamUrl1);

                if (audioBuffer1.duration < secondsPackageTime) {
                    nextAudioBuffer = await fetchAudio(audioStreamUrl2);
                    currentApi = 2;
                } else {
                    nextAudioBuffer = audioBuffer1;
                    currentApi = 1;
                }

                firstReproduction = false;
            } else {
                const apiUrl = currentApi === 1 ? audioStreamUrl2 : audioStreamUrl1;
                nextAudioBuffer = await fetchAudio(apiUrl);
                currentApi = currentApi === 1 ? 2 : 1;
            }
        }

        async function playAudio() {
            isPlaying = true;

            await prepareNextAudio();

            while (isPlaying) {
                if (nextAudioBuffer) {
                    audioPlayer.src = URL.createObjectURL(audioBufferToWav(nextAudioBuffer));
                    audioPlayer.play();

                    await sleep(secondsDelayApi);
                    await prepareNextAudio();

                    await new Promise(resolve => {
                        audioPlayer.onended = async () => {
                            resolve();
                        };
                    });
                }
            }
        }

        async function pauseAudio() {
            let isPlaying = false;
            let firstReproduction = true;
            let nextAudioBuffer = null;
            let currentApi = 0;
        }

        function sleep(seconds) {
            return new Promise(resolve => setTimeout(resolve, seconds * 1000));
        }

        function audioBufferToWav(buffer) {
            const numChannels = buffer.numberOfChannels;
            const sampleRate = buffer.sampleRate;
            const length = buffer.length * numChannels * 2 + 44;
            const wavBuffer = new ArrayBuffer(length);
            const view = new DataView(wavBuffer);

            writeString(view, 0, 'RIFF');
            view.setUint32(4, length - 8, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, length - 44, true);

            let offset = 44;
            for (let channel = 0; channel < numChannels; channel++) {
                const channelData = buffer.getChannelData(channel);
                for (let i = 0; i < channelData.length; i++, offset += 2) {
                    const sample = Math.max(-1, Math.min(1, channelData[i]));
                    view.setInt16(offset, sample < 0 ? sample * 0x8000 : sample * 0x7FFF, true);
                }
            }

            return new Blob([wavBuffer], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        audioPlayer.addEventListener('play', () => {
            if (!isPlaying) {
                playAudio();
            }
        });

        audioPlayer.addEventListener('pause', () => {
            if (isPlaying) {
                pauseAudio();
            }
        });

        audioPlayer.addEventListener('volumechange', () => {
            gainNode.gain.value = audioPlayer.volume;
        });

        playOverlay.addEventListener('click', () => {
            if (audioPlayer.paused) {
                audioPlayer.play();
                playOverlay.style.display = 'none';
            }
        });
    </script>
</body>
</html>